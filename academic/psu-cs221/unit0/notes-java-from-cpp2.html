<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"><html><head><title>To Java from C++, Part II</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><? // grab the headerinclude 'notes-header.php' ; ?><h1 align="center"><font color="#990066"> To  Java from C++, Part II </font></h1><p align="right"><font size="-1">Last Modified   <!-- #BeginDate format:Am2 -->8/27/11<!-- #EndDate --></font></p><p align="center">	<font size="1">		<a href="#methods">Methods</a> &bull; 		<a href="#static">Static Methods</a> &bull; 		<a href="#api">API Packages</a> &bull;         <a href="#random">Random Numbers</a> &bull;         <a href="#foreach">Enhanced For Loop</a> &bull; 		<a href="#vararg">Variable Length Arg Lists</a> &bull; 		<a href="#arrays_class">Arrays Class</a></font></p><hr><h2><font color="#990033"><font color="#990066"><a name="methods"></a>Methods in Java </font></font></h2><p>Creating and using methods in Java is very similar to using methods in C++, so I'll summarize some key issues here (and move on to some specifics unique to Java):</p><ul>  <li>The idea of writing a method once and being able to call it many times elsewhere is the same.</li>  <li>The ideas of parameters, arguments, scope, and local variables are all the same.</li>  <li>The idea of return types is the same, as is the process for calling both void and value-returning functions.</li>  <li>Methods may be overloaded in Java as in C++; a method's uniqueness depends on its signature (return type, name, and types of parameters).</li>  <li>In Java we add access specifiers (e.g. <font face="Courier New, Courier, mono">public</font> or <font face="Courier New, Courier, mono">private</font>) to individual methods before the return type. </li>  <li>Passing arrays to methods is very similar in Java:    <ul>      <li>Like in C++, we pass arrays with empty brackets. The only difference is that in Java the brackets come before the name of the array in the function header, not after like in C++:          <blockquote>            <pre>public void foo(int[] passedArray, int size)</pre>          </blockquote>      </li>      <li>As in C++, only the name of the argument array is used in the function call:         <blockquote>          <pre>foo(myArray, 4);</pre>        </blockquote>      </li>    </ul>  </li>  <li>Java dictates how parameters are passed based on their types:    <ul>      <li>Primitive-type variables are passed by value. Thus, no changes made to primitive-type parameters in methods will persist. The way to get around this is to use a wrapper class, i.e. Integer. But, you won't likely need to worry about this issue too often as we get truly object-oriented. </li>      <li>Reference-type variables (including arrays) are passed by reference. Thus, if you change an array that's a parameter to a method within the method, that change will persist. (By the way, that's the same behavior as in C++.) Objects are passed by reference by default.  </li>    </ul>  </li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#methods">Methods</a> &bull; <a href="#static">Static Methods</a> &bull; <a href="#api">API Packages</a> &bull; <a href="#random">Random Numbers</a> &bull; <a href="#foreach">Enhanced For Loop</a> &bull; <a href="#vararg">Variable Length Arg Lists</a> &bull; <a href="#arrays_class">Arrays Class</a></font></p><hr><h2><font color="#990033"><font color="#990066"><a name="static"></a>Static Methods </font></font></h2><p>All of the methods we saw last time in the <font face="Courier New, Courier, mono">Math</font> class are methods that have the dot operator operating on the <em>class </em>name instead of on an <em>object</em> name. This might seem a bit odd to you, but none of these methods <em>require</em> an object. They behave exactly the same. Methods such as these that are not linked to objects of a class are called <strong>static methods</strong>. </p><p>Back up to when we learned about the main method in Java, which had this header: </p><blockquote>  <pre>public <font color="#000066"><strong>static</strong></font> void main(String[] args)</pre></blockquote><p>Notice that main is also static; it doesn't depend on any instance of the class. </p><p><strong>IMPORTANT:</strong> Methods marked <font face="Courier New, Courier, mono">static</font> within a class can call only other static methods within the same class. They cannot call methods that depend on instance variables of the class. </p><p>At the same time, note that a static method of any class can be called using the class name instead of an object name in another class (as with <font face="Courier New, Courier, mono">Math</font> examples). </p><p>As a result of this requirement, if we write a program that's not really object-oriented, yet uses helper methods that are called from <font face="Courier New, Courier, mono">main</font>, those methods must be <font face="Courier New, Courier, mono">static</font>. The static keyword appears just where you see in <font face="Courier New, Courier, mono">main</font>: after the <font face="Courier New, Courier, mono">public</font> or <font face="Courier New, Courier, mono">private</font> and before the return type. </p><p>&nbsp;</p><h3><font color="#990000">Example</font></h3><p>Consider the following method and call from <font face="Courier New, Courier, mono">main</font>: </p><blockquote>  <pre>public <strong><font color="#000066">static</font></strong> double Percentage(int numer, int denom)<br>// PRE:  ___________________________________________________________<br>// POST: FCTVAL == percentage numer is of denom, e.g. 95.1 {<br>   return ((double) numer)/denom*100; <br>}public <font color="#000066"><strong>static</strong></font> void main(String[] args){   System.out.printf(&quot;8/11 = %.1f percent\n&quot;, Percentage(8,11));}</pre></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#methods">Methods</a> &bull; <a href="#static">Static Methods</a> &bull; <a href="#api">API Packages</a> &bull; <a href="#random">Random Numbers</a> &bull; <a href="#foreach">Enhanced For Loop</a> &bull; <a href="#vararg">Variable Length Arg Lists</a> &bull; <a href="#arrays_class">Arrays Class</a></font></p><hr><h2><font color="#990066"><a name="api"></a>API Packages </font></h2><p>There are many built-in libraries in Java that may come in handy. These libraries are collectively known as the <a href="http://java.sun.com/javase/6/docs/api/overview-summary.html">Java Application Programming Interface (or API)</a>. (The link for <font face="Courier New, Courier, mono">Math</font> above came from drilling down in the API.) </p><p>See 6.8 of Deitel for a bit more information and explore the link at your leisure. </p><p>As you proceed through the course and work on projects, you'll find the API to be a great resource. My personal advice: Use Google. A Google search for &quot;Java API&quot; and the name of a standard Java class (e.g. &quot;Java API String&quot;) has never failed to give me the page I want as one of the first few results. </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#methods">Methods</a> &bull; <a href="#static">Static Methods</a> &bull; <a href="#api">API Packages</a> &bull; <a href="#random">Random Numbers</a> &bull; <a href="#foreach">Enhanced For Loop</a> &bull; <a href="#vararg">Variable Length Arg Lists</a> &bull; <a href="#arrays_class">Arrays Class</a></font></p><hr><h2><font color="#990033"><font color="#990066"><a name="random"></a>Random Numbers </font></font></h2><p>Java handles random numbers via a static method of the <font face="Courier New, Courier, mono">Math</font> class. Calling <font face="Courier New, Courier, mono">Math.random()</font> returns a uniformly distributed random number between 0.0 and 1.0. </p><p>Unlike C++, there is no seeding necessary and no header files for using random numbers. </p><p>Let's recall how we work with random numbers. </p><p><strong>Class Exercise 1: </strong>Write a line of code to generate a random number between 0 and 10 and store it in <font face="Courier New, Courier, mono">rand1</font>. </p><p>&nbsp;</p><p>&nbsp;</p><p><strong>Class Exercise 2: </strong>Write a line of code to generate a random number between 18 and 50 and store it in <font face="Courier New, Courier, mono">rand2</font>. </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#methods">Methods</a> &bull; <a href="#static">Static Methods</a> &bull; <a href="#api">API Packages</a> &bull; <a href="#random">Random Numbers</a> &bull; <a href="#foreach">Enhanced For Loop</a> &bull; <a href="#vararg">Variable Length Arg Lists</a> &bull; <a href="#arrays_class">Arrays Class</a></font></p><hr><h2><font color="#990066"><a name="foreach"></a>The Enhanced <font face="Courier New, Courier, mono">for</font> Loop </font></h2><p>A relatively recent addition to Java is a new form of the <font face="Courier New, Courier, mono">for</font> loop that allows us to iterate through an array without accessing elements by their indices. Instead, it uses a temporary placeholder variable for each element of the array. </p><p>This placeholder must be of the same type as the elements of the array and we declare it within the loop header just like an LCV. For the first iteration of the loop, the placeholder takes on the array element at index 0. It is then moved through the array element by element until the last element. </p><p>Here's the general form: </p><blockquote>  <pre><strong><font color="#FF6600">for(</font></strong> <em>array_data_type</em>  <em>placeholder_name</em> <font color="#FF6600"><strong> :</strong></font>  <em>array_name</em> <strong><font color="#FF6600">){</font></strong>   // loop body logic, in terms of placeholder_name<font color="#FF6600"><strong>}</strong></font></pre></blockquote><p>Here's a simple example: </p><blockquote>  <pre>int[] array2 = {4, 2, 5, 2, 1};for(int num : array2){   System.out.println(&quot;next val: &quot; + num);}</pre></blockquote><p>One benefit to this structure is that we never risk exceeding the bounds of the array. </p><p>&nbsp;</p><h3><font color="#990066">Discussion</font></h3><p>Now that we have learned about all four kinds of loops in Java, let's review and discuss appropriate usage of the loops:</p><ul>  <li>What is the first question we should ask in evaluating the proper loop choice for <em>all</em> looping problems?</li>  <li>If the answer to the above question is &quot;no,&quot; how do we further decide the appropriate loop?</li>  <li>Does the enhanced <font face="Courier New, Courier, mono">for</font> replace the regular <font face="Courier New, Courier, mono">for</font> loop? </li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp; </p><p>&nbsp;</p><p align="center"><font size="1"><a href="#methods">Methods</a> &bull; <a href="#static">Static Methods</a> &bull; <a href="#api">API Packages</a> &bull; <a href="#random">Random Numbers</a> &bull; <a href="#foreach">Enhanced For Loop</a> &bull; <a href="#vararg">Variable Length Arg Lists</a> &bull; <a href="#arrays_class">Arrays Class</a></font></p><hr><h2><font color="#990033"><font color="#990066"><a name="vararg"></a>Variable Length Argument Lists </font></font></h2><p>Java allows us to write methods that take in several arguments of the same type without knowing how many arguments the client will send. Essentially, what is going on is we are sending in an array. </p><p>In the method header, we give a single parameter that is of the data type for the arguments we want. Instead of using brackets like with an array, we use an ellipsis:</p><blockquote>  <pre><em>data_type</em><strong><font color="#FF6600">...</font></strong><em> name </em></pre></blockquote><p>Here's a more specific example: </p><pre>    public static void PrintVals(int... values)<br>    // PRE:  values contain one or more initialized values<br>    // POST: all elements in values are displayed in a line<br>    //       with spaces between<br>    {<br>        for(int num : values)<br>        {<br>            System.out.print(num + &quot;  &quot;);<br>        }<br>    }</pre><p>Here <font face="Courier New, Courier, mono">values</font> is essentially an array, and we process it as such. The enhanced for loop works nicely here due to not knowing the number of elements in <font face="Courier New, Courier, mono">values</font>, but needing to iterate through all of them. </p><p>Consider a few example calls to this method: </p><blockquote>  <pre>PrintVals(3);PrintVals(3, 6, 2);</pre></blockquote><p>&nbsp;</p><p><strong>Question: </strong>Could we have other parameters in a method with a variable-length argument list? How do you think we could do this or why do you think we can't? </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#methods">Methods</a> &bull; <a href="#static">Static Methods</a> &bull; <a href="#api">API Packages</a> &bull; <a href="#random">Random Numbers</a> &bull; <a href="#foreach">Enhanced For Loop</a> &bull; <a href="#vararg">Variable Length Arg Lists</a> &bull; <a href="#arrays_class">Arrays Class</a></font></p><hr><h2><font color="#990066"><font face="Courier New, Courier, mono"><a name="arrays_class"></a>Arrays</font> Class Methods </font></h2><p>Java provides a library called <font face="Courier New, Courier, mono">Arrays</font> with some common array operations pre-coded for you. </p><p>To use this library, we need the following import statement: </p><blockquote>  <pre>import java.util.Arrays;</pre></blockquote><p>Here are some methods provided by <font face="Courier New, Courier, mono">Arrays</font>:</p><table border="1" cellspacing="0" cellpadding="3">  <tr>    <th scope="col">Method Header </th>    <th scope="col">Input Notes </th>    <th scope="col">Postcondition</th>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">Arrays.<font color="#FF6600"><strong>fill</strong></font>(<em>array</em>, <em>value</em>)</font></td>    <td><font face="Courier New, Courier, mono">value</font> must be initialized and of same type as <font face="Courier New, Courier, mono">array</font> </td>    <td>all elements of <font face="Courier New, Courier, mono">array</font> from <font face="Courier New, Courier, mono">0</font> to <font face="Courier New, Courier, mono">array.length-1</font> are set to <font face="Courier New, Courier, mono">value</font> </td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">Arrays.<font color="#FF6600"><strong>sort</strong></font>(<em>array</em>)</font></td>    <td>any value of <font face="Courier New, Courier, mono">array</font> is fine, but it makes sense for it to be initialized</td>    <td><font face="Courier New, Courier, mono">array[0..array.length-1]</font> are sorted in ascending order </td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">Arrays.<strong><font color="#FF6600">binarySearch</font></strong>(<em>array, key</em>) </font></td>    <td><font face="Courier New, Courier, mono">array</font> must be sorted in ascending order and <font face="Courier New, Courier, mono">key</font> must be a value of the same type as <font face="Courier New, Courier, mono">array</font> </td>    <td><p>A binary search has been done on <font face="Courier New, Courier, mono">array[0..array.length-1]</font> and the location of <font face="Courier New, Courier, mono">key</font> is returned if key is found. Otherwise, a negative value is returned. </p>        <p>Remember how binary search works when sending arrays with repeated values....</p></td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">Arrays.<strong><font color="#FF6600">equals</font></strong>(<em>array1</em>, <em>array2</em>)</font></td>    <td><font face="Courier New, Courier, mono">array1</font> and <font face="Courier New, Courier, mono">array2</font> must be initialized</td>    <td>Returns true if all elements of <font face="Courier New, Courier, mono">array1</font> and <font face="Courier New, Courier, mono">array2</font> are the same, false otherwise. </td>  </tr></table><p>&nbsp;</p><p>Here are a few examples:</p><blockquote>  <pre>Arrays.sort(array2);loc = Arrays.binarySearch(array2, 2);<br>System.out.printf(&quot;2 was found at %d&quot;, loc);Arrays.fill(array2, 0);if(Arrays.equals(array, array2)){<br>    System.out.println(&quot;They're the same!&quot;);}<br>  </pre></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#methods">Methods</a> &bull; <a href="#static">Static Methods</a> &bull; <a href="#api">API Packages</a> &bull; <a href="#random">Random Numbers</a> &bull; <a href="#foreach">Enhanced For Loop</a> &bull; <a href="#vararg">Variable Length Arg Lists</a> &bull; <a href="#arrays_class">Arrays Class</a></font></p></body></html>