<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"><html><head><title>Aggregate Functions and Changing Data</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><? // grab the headerinclude 'notes-header.php' ; ?><h1 align="center"><font color="#993300">Aggregate Functions and Changing  Data </font></h1><p align="right"><font size="-1">Last Modified   <!-- #BeginDate format:Am2 -->4/9/12<!-- #EndDate --></font></p><p align="center">	<font size="1">		<a href="#groupby">Group by</a> &bull; 		<a href="#having">Having</a> &bull; 		<a href="#aggreg">Aggregate Functions</a> &bull; 		<a href="#delete">Deleting Records</a> &bull; 		<a href="#update">Updating Records</a> 	</font></p><hr><h2><font color="#993300"><a name="groupby"></a>The <font face="Courier New, Courier, mono">group by</font> Clause </font></h2><p>Consider the following query we could have written with the most basic of our knowledge of <font face="Courier New, Courier, mono">select</font> statements: </p><blockquote>  <pre>select credits from courses; </pre></blockquote><p>We could visually inspect the result set and count how many courses were 1 credit, 3 credits, etc. However, if the result set were to grow large, this would get tedious and potentially inaccurate. We can simplify the counting with the following query:</p><blockquote>  <pre>  select credits, count(*)<br>    from courses<br>group by credits;</pre></blockquote><p>This query a single row of output for each unique value of <font face="Courier New, Courier, mono">credits</font> represented in the table due to the <font face="Courier New, Courier, mono">group by credits</font> clause. In each row, we'll see the value of <font face="Courier New, Courier, mono">credits</font> and how many records have that value. </p><p>In general, we can use the <font face="Courier New, Courier, mono">group by </font> clause to select all of the records that have the same value for some field and generate summary data for those records. </p><p>Here's another query on the sample database provided with NetBeans to consider:</p><blockquote>  <pre>  select customer_id, count(*)<br>    from purchase_order<br>   where customer_id &lt; 300<br>group by customer_id;  </pre></blockquote><p>Here we filter the records and group records. </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#groupby">Group by</a> &bull; <a href="#having">Having</a> &bull; <a href="#aggreg">Aggregate Functions</a> &bull; <a href="#delete">Deleting Records</a> &bull; <a href="#update">Updating Records</a> </font></p><hr><h2><font color="#993300"><a name="having"></a>The <font face="Courier New, Courier, mono">having</font> clause </font></h2><p>Suppose we wanted to filter the results in the last example further and we wanted to look at only those customers who had exactly 2 purchase orders. Notice the order of the clauses. Because grouping is done after filtering records, we cannot use <font face="Courier New, Courier, mono">count(*)</font> in the <font face="Courier New, Courier, mono">where</font> clause. </p><p>So, we need another way: the <font face="Courier New, Courier, mono">having</font> clause, which can used to filter groups. Expressions in the <font face="Courier New, Courier, mono">having</font> clause are built using <font face="Courier New, Courier, mono">count(*)</font> and similar functions that operate on groups that we'll see soon. </p><p>Consider this example:</p><blockquote>  <pre>  select customer_id, count(*)<br>    from purchase_order<br>   where customer_id &lt; 300<br>group by customer_id<br>  having count(*) = 2;</pre></blockquote><p>&nbsp;</p><p>Notice that we've now seen all six parts of a <font face="Courier New, Courier, mono">select</font> statement. Let's put them all together in an example: </p><blockquote>  <pre>  select customer_id, count(*)<br>    from purchase_order<br>   where customer_id &lt; 300<br>group by customer_id<br>  having count(*) = 2<br>order by customer_id desc;</pre></blockquote><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#groupby">Group by</a> &bull; <a href="#having">Having</a> &bull; <a href="#aggreg">Aggregate Functions</a> &bull; <a href="#delete">Deleting Records</a> &bull; <a href="#update">Updating Records</a> </font></p><hr><h2><font color="#993300"><a name="aggreg"></a>Aggregate Functions </font></h2><p>The function <font face="Courier New, Courier, mono">count(*)</font> we saw above is called an <strong>aggregate function</strong>, i.e. a function that operates on grouped data. </p><p>Here are some more, whose meanings should be obvious:</p><ul>  <li><font face="Courier New, Courier, mono">max</font></li>  <li><font face="Courier New, Courier, mono">min</font></li>  <li><font face="Courier New, Courier, mono">avg</font></li>  <li><font face="Courier New, Courier, mono">sum</font></li></ul><p>We can use any of these functions in <font face="Courier New, Courier, mono">select</font> statements, but note that if we use one aggregate field in what we're selecting, all fields must be aggregate.</p><p>Consider the following examples:</p><blockquote>  <pre>  select customer_id, sum(shipping_cost) total_spent<br>    from purchase_order<br>group by customer_id<br>  having sum(shipping_cost) &gt; 500<br>order by sum(shipping_cost) desc;<br> select max(quantity), min(quantity), max(shipping_cost), <br>        min(shipping_cost), avg(shipping_cost)<br>   from purchase_order;   select customer_id, max(shipping_cost)<br>    from purchase_order<br>group by customer_id;</pre></blockquote><p>&nbsp; </p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#groupby">Group by</a> &bull; <a href="#having">Having</a> &bull; <a href="#aggreg">Aggregate Functions</a> &bull; <a href="#delete">Deleting Records</a> &bull; <a href="#update">Updating Records</a> </font></p><hr><h2><font color="#993300"><a name="delete"></a>Deleting Records </font></h2><p>We can remove records from tables with the <font face="Courier New, Courier, mono">delete</font> statement. </p><p>Here's a general form:</p><blockquote>  <pre><strong><font color="#990000">delete from</font></strong> <em>tableName</em> <strong><font color="#990000">where</font></strong> <em>expression</em>; </pre></blockquote><p>Consider the following example, which deletes a single record: </p><blockquote>  <pre>delete from courses  where course_id = 40; </pre></blockquote><p>Here's an example that deletes several records, perhaps if we'd erroneously just made several entries:</p><blockquote>  <pre>delete from courses  where course_id &gt; 40; </pre></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#groupby">Group by</a> &bull; <a href="#having">Having</a> &bull; <a href="#aggreg">Aggregate Functions</a> &bull; <a href="#delete">Deleting Records</a> &bull; <a href="#update">Updating Records</a> </font></p><hr><h2><font color="#993300"><a name="update"></a>Changing Records </font></h2><p>Via the <font face="Courier New, Courier, mono">update</font> statement, we can change existing records. </p><p>Here's a general form:</p><blockquote>  <pre><strong><font color="#990000">update </font></strong><em>tableName</em>   <font color="#990000"><strong>set</strong></font> <em>columnName1 = value, columnName2 = value2, ... </em><strong><font color="#990000">where</font></strong> <em>expression</em>; </pre></blockquote><p>Consider the following example: </p><blockquote>  <pre>update courses<br>   set number = 103, credits = 4<br> where course_id = 1;</pre></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#groupby">Group by</a> &bull; <a href="#having">Having</a> &bull; <a href="#aggreg">Aggregate Functions</a> &bull; <a href="#delete">Deleting Records</a> &bull; <a href="#update">Updating Records</a> </font></p></body></html>