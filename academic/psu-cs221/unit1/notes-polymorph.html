<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"><html><head><title>Polymorphism</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><style type="text/css"><!--.style7 {color: #CC6600}.style8 {font-family: "Courier New", Courier, mono}.style9 {	color: #FF6600;	font-weight: bold;}.style10 {color: #000066}.style12 {color: #000066; font-weight: bold; }--></style></head><body><? // grab the headerinclude 'notes-header.php' ; ?><h1 align="center" class="style7">Polymorphism</h1><p align="right"><font size="-1">Last Modified <!-- #BeginDate format:Am2 -->9/17/11<!-- #EndDate --></font></p><p align="center"><font size="1">		<a href="#idea">Polymorphism Defined</a> &bull; 		<a href="#isahasa">is-a/has-a</a> &bull; 		<a href="#abstract">Abstract Methods</a> &bull; 		<a href="#abclass">Abstract Classes</a> &bull;		<a href="#ex">Example Code</a> &bull;		<a href="#interface">Interfaces</a> &bull;		<a href="#int_ex">Interface Code</a>  </font></p><hr><h2><font color="#990033"><a name="idea"></a></font><span class="style7">What is Polymorphism?</span></h2><p>Let's dissect:</p><ul>  <li><strong>poly = </strong>many</li>  <li><strong>morph =</strong> form</li></ul><p>So, <strong>polymorphism</strong>, literally, means &quot;many forms.&quot; </p><p>This is the idea that we can program an operation that behaves in many different ways. It's related to the idea of inheritance. Suppose we have an operation that is common to all members of an inheritance hierarchy, but how that operation is done for all members is unique to each member. The operation takes on many forms. </p><p>Which of the forms of the operation is appropriate for the object is determined at runtime. Objects know their types, and methods are linked to types. Even though many forms of a given method exists, the correct one is bound to the call when code is run. This is the idea of <strong>dynamic binding</strong>.</p><p>To use Deitel's terminology, polymorphism allows us to &quot;program in the general&quot; rather than &quot;program in the specific.&quot; If we have polymorphic behaviors defined for objects, we don't have to worry about what particular type the objects are when using them; we define operations for each classification and leave the linking up to dynamic binding. (Lots of if statements and type manipulation would otherwise be necessary.)</p><h3 class="style7">Example 1</h3><p>Suppose we add drawing functionality into our shapes hierarchy (something we'll learn how to do in the next unit). Every shape ought to be able to draw itself, so we should be able to write a method called <span class="style8">draw()</span> in the <span class="style8">Shape</span> class. Each subclass of <span class="style8">Shape</span> will have to implement this method and may do so differently. How a circle is drawn is very different from how a trapezoid is drawn. </p><p>We might want an array of shapes and want to loop through the array, asking each shape to draw itself. It is via polymorphism that this is possible, and easy. </p><p><em>Question</em>: How would we implement the <span class="style8">draw()</span> method in the <span class="style8">Shape</span> class? </p><p>&nbsp;</p><h3 class="style7">Example 2 </h3><p>Suppose we have a way of generating sound and we're simulating music. Suppose we have a class hierarchy like this:</p><ul>  <li>Instrument    <ul>      <li>BrassInstrument        <ul>          <li>Trumpet</li>          <li>Trombone</li>        </ul>      </li>      <li>WoodwindInstrument        <ul>          <li>Flute</li>          <li>Saxophone</li>        </ul>      </li>      <li>StringInstrument        <ul>          <li>Violin</li>          <li>Guitar</li>        </ul>      </li>      <li>PercussionInstrument        <ul>          <li>Drum</li>          <li>Piano</li>        </ul>      </li>    </ul>  </li></ul><p>The notes that each instrument work with are the same and we ought to be able to feed each instrument a song and ask it to play the song. We might define a method <span class="style8">playNote()</span> in <span class="style8">Instrument</span>, but how each note sounds is determined by the instrument itself. Maybe this method might abstract the idea of how long to play the note, which might be common to many instruments, but the sounds require polymorphism. </p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#idea">Polymorphism Defined</a> &bull; <a href="#isahasa">is-a/has-a</a> &bull; <a href="#abstract">Abstract Methods</a> &bull; <a href="#abclass">Abstract Classes</a> &bull; <a href="#ex">Example Code</a> &bull; <a href="#interface">Interfaces</a> &bull; <a href="#int_ex">Interface Code</a> </font></p><hr><h2><font color="#990033"><a name="isahasa"></a></font><span class="style7">IS-A and HAS-A Relationships </span></h2><p>The relationship between classes becomes important in designing large scale object-oriented projects. Two basic relationships are <em>IS-A</em> and <em>HAS-A</em>:</p><ul>  <li>We say <em>A</em> <strong>is-a</strong> <em>B</em> when class <em>A </em>is a subclass of class <em>B</em>.</li>  <li>We say <em>A</em> <strong>has-a</strong> <em>B</em> when class <em>A</em> contains an object of class <em>B</em> among its member data. </li></ul><p>The best design keeps classes small and specialized. </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#idea">Polymorphism Defined</a> &bull; <a href="#isahasa">is-a/has-a</a> &bull; <a href="#abstract">Abstract Methods</a> &bull; <a href="#abclass">Abstract Classes</a> &bull; <a href="#ex">Example Code</a> &bull; <a href="#interface">Interfaces</a> &bull; <a href="#int_ex">Interface Code</a> </font></p><hr><h2><font color="#990033"><a name="abstract"></a></font><span class="style7">Abstract Methods </span></h2><p>Polymorphism allows us to have different forms of the same method for different subclasses of a superclass, but what happens when it's not possible to define some method for a superclass? Consider our drawing example for shapes. We want drawing capabilities for all shapes and it makes sense to have a general shape class from which all specific kinds of shapes inherit, but it's not possible to define how to draw a shape we haven't defined. This is a perfect example of the need for an <em>abstract method</em>. </p><p>An <strong>abstract method </strong>is one that is defined without an implementation. Instead of providing an implementation, we assume that this method will be implemented in subclasses of the class containing this method. </p><p>We declare abstract methods by adding keyword <span class="style8">abstract</span> in the method name and by providing only a function declaration, not an implementation. This is the same idea as a function prototype in C++. </p><p>Here's how we'd define the aforementioned drawing method in the <span class="style8">Shape</span> class:</p><blockquote>  <pre>public <span class="style9">abstract</span> void Draw()<span class="style9">;</span>// POST: current object has been drawn on the screen</pre></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#idea">Polymorphism Defined</a> &bull; <a href="#isahasa">is-a/has-a</a> &bull; <a href="#abstract">Abstract Methods</a> &bull; <a href="#abclass">Abstract Classes</a> &bull; <a href="#ex">Example Code</a> &bull; <a href="#interface">Interfaces</a> &bull; <a href="#int_ex">Interface Code</a> </font></p><hr><h2><font color="#990033"><a name="abclass"></a></font><span class="style7">Abstract Classes </span></h2><p>Abstract methods are declared as part of <strong>abstract classes</strong>, those which cannot be instantiated. Such classes... </p><ul>  <li>are always superclasses in inheritance hierarchies.</li>  <li>do not fully define all behaviors and members, but define <em>what</em> behaviors and data are necessary to define objects of some type. </li>  <li>can be contrasted with <strong>concrete classes</strong>, i.e. those which can be instantiated.</li></ul><p>To declare an abstract class, we add keyword <span class="style8">abstract</span> to its definition.</p><p>The Shape class we've been discussing would appropriately be an abstract class:</p><blockquote>  <pre>public <span class="style9">abstract</span> class Shape{   //...}</pre></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#idea">Polymorphism Defined</a> &bull; <a href="#isahasa">is-a/has-a</a> &bull; <a href="#abstract">Abstract Methods</a> &bull; <a href="#abclass">Abstract Classes</a> &bull; <a href="#ex">Example Code</a> &bull; <a href="#interface">Interfaces</a> &bull; <a href="#int_ex">Interface Code</a> </font></p><hr><h2><font color="#990033"><a name="ex"></a></font><span class="style7">Code Example</span></h2><p><font size="1">(Adapted from a project in Mercer)</font></p><p>Suppose we are implementing a program for a library that allows users to check out books, DVDs, and CDs, but policies are different for each kind of object. Let's look at some of this system. </p><h3 class="style7">Superclass LibraryObject</h3><p>Here is code for a superclass for all of these objects:</p><blockquote>  <pre>public abstract class LibraryObject{    protected static int curMonth = 9;   // current month number    protected static int curDate = 1;    // current day number    protected String title;              // title of object    protected String call_number;        // call number of object in library system    protected boolean isAvail;           // availability indicator: true when object is                                          //   not checked out, false when it is    protected int monthDue;              // number of month object is due back    protected int dateDue;               // date of monthDue when object is due back    public LibraryObject()    // POST: new LibraryObject constructed such that     //       title and call_number are set to blank strings and isAvail is true    {        title = "";        call_number = "";        isAvail = true;    }    public abstract void CheckOut();    // PRE:  class member isAvail == true    // POST: isAvail is set to false and monthDue and dateDue are reset    //       according to what type of item this is    public void ResetDueDate(int numDays)    // PRE:  numDays > 0    // POST: monthDue and dateDue are adjusted numDays into the future    {        monthDue = curMonth;         dateDue = curDate + numDays;   // lazy implementation -- can you fix it?    }    public String GetStatus()    // POST: FCTVAL == string stating "Available" if item is available or    //                 "Due Back [month]/[date]" is item is checked out    {        if(isAvail)                     // item is not checked out        {            return "Available";        }        else                            // item is checked out        {            return "Due Back " + monthDue + "/" + dateDue;        }    }}</pre></blockquote><p>Notice that because of how different items would be checked out for different numbers of days, the modifier to check out an item and the class are both abstract. </p><p>&nbsp;</p><h3 class="style7">Subclass LibraryBook</h3><p>Here is partial code for one kind of item that could be checked out of this library: </p><blockquote>  <pre>public class LibraryBook extends LibraryObject{    private String author;              // author of the book    @Override    public void CheckOut()    // PRE:  class member isAvail == true    // POST: isAvail is set to false and monthDue and dateDue are reset    //       to 3 weeks in the future    {        isAvail = false;        ResetDueDate(21);      // book will be checked out for 3 weeks = 21 days    }}</pre></blockquote><p>&nbsp;</p><h3 class="style7">Subclass LibraryDVD</h3><p>Here is partial code for another kind of item that could be checked out of this library: </p><blockquote>  <pre>public class LibraryDVD extends LibraryObject{    private String genre;       // type of DVD, e.g., "movie," "educational"        @Override    public void CheckOut()    // PRE:  class member isAvail == true    // POST: isAvail is set to false and monthDue and dateDue are reset    //       to 5 days in the future    {        isAvail = false;        ResetDueDate(5);        // DVD is due 5 days from now    }}</pre></blockquote><p>&nbsp;</p><h3 class="style7">Test Driver</h3><p>Here is a main program that tests the system above:</p><blockquote>  <pre>public class LibraryTest{    public static void main(String[] args)    {        LibraryObject[] lib = new LibraryObject[4];     // library        lib[0] = new LibraryBook();             // create some items        lib[1] = new LibraryDVD();        lib[2] = new LibraryBook();        lib[3] = new LibraryDVD();        System.out.println("Initial Library: ");        for(LibraryObject cur : lib)            // go through whole library        {            System.out.println(cur.GetStatus());        }        lib[0].CheckOut();                      // check out some items        lib[1].CheckOut();        lib[3].CheckOut();         System.out.println("\nLibrary after check outs:");        for(LibraryObject cur : lib)            // go through whole library        {            System.out.println(cur.GetStatus());        }    }}</pre></blockquote><p>Notice how we make an array of superclass objects, yet instantiate objects based upon the subclasses. Also, notice how polymorphism simplifies the code both in checking out objects and in displaying the state of the library. </p><p>Inspect the output for yourself: </p><blockquote>  <pre>Initial Library: <br>Available<br>Available<br>Available<br>Available</pre>  <pre>Library after check outs:Due Back 9/22Due Back 9/6AvailableDue Back 9/6</pre></blockquote><p>&nbsp;</p><p><strong>Food for thought:</strong> Could you add CDs into the system? How about late fees? </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#idea">Polymorphism Defined</a> &bull; <a href="#isahasa">is-a/has-a</a> &bull; <a href="#abstract">Abstract Methods</a> &bull; <a href="#abclass">Abstract Classes</a> &bull; <a href="#ex">Example Code</a> &bull; <a href="#interface">Interfaces</a> &bull; <a href="#int_ex">Interface Code</a> </font></p><hr><h2><font color="#990033"><a name="interface"></a></font><span class="style7">Interfaces &amp; Multiple Inheritance </span></h2><p>A class can only extend <strong>one</strong> other class in Java. If a class could extend more than one class, we'd have a situation called <strong>multiple inheritance</strong>. However, this is disallowed in Java, as it's quite messy. </p><p>Nevertheless, there are times we wish to pull some common behavior from multiple classes into overarching structures. As long as all of this behavior is <em>abstractly</em> defined, we <em>can</em> create what we call an <strong>interface</strong>, which is a structure like an abstract class where all member methods are abstract. Additionally, interfaces may <em>not</em> contain non-static data members. (You might put static members, particularly constants, in an interface.) </p><p>Instead of saying a class <em>extends</em> an interface, we say that a class <em>implements</em> an interface, as an interface cannot be instantiated. It <em>is</em> possible for a class to implement multiple interfaces. </p><p>Because of the nature of an interface, all methods must be <span class="style8">public</span>, <span class="style8">static</span>, and <span class="style8">final</span>. As a result, it is not necessary to include any of these keywords in an interface definition. </p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#idea">Polymorphism Defined</a> &bull; <a href="#isahasa">is-a/has-a</a> &bull; <a href="#abstract">Abstract Methods</a> &bull; <a href="#abclass">Abstract Classes</a> &bull; <a href="#ex">Example Code</a> &bull; <a href="#interface">Interfaces</a> &bull; <a href="#int_ex">Interface Code</a> </font></p><hr><h2><font color="#990033"><a name="int_ex"></a></font><span class="style7">Interfaces in Code </span></h2><p>Here's the general form of an interface:</p><blockquote>  <pre><span class="style12">public interface </span><em>InterfaceName</em><span class="style10"><strong>{</strong></span>   // definitions of methods, e.g.   // void MethodName();<span class="style12">}</span></pre></blockquote><p>Here's how a class to implement an interface might start:</p><blockquote>  <pre><span class="style10"><strong>public class</strong></span> <em>ClassName</em> <span class="style10"><strong>implements</strong></span> <em>InterfaceName</em><span class="style12">{</span>   // class code   // must contain implementation of each method in InterfaceName<span class="style12">}</span></pre></blockquote><p>&nbsp;</p><h3 class="style7">Example from Deitel</h3><p>Let's look at the highlights of an example of an interface. This code is taken directly from Section 10.7 of Deitel. Consult the book for the complete code.</p><p>This code defines an interface called Payable, designed to be used with all sorts of objects who can be paid:</p><blockquote>  <pre>public interface Payable{   double getPaymentAmount();   // POST: FCTVAL == amount paid in dollars}</pre></blockquote><p>Here's part of the code for an invoice:</p><blockquote>  <pre>public class Invoice implements Payable{   //...   @Override   public double getPaymentAmount()   // POST: FCTVAL == payment owed on this Invoice in dollars   {      return getQuantity() * getPricePerItem();   }}</pre></blockquote><p>Here's part of the code for an employee, which does not implement <span class="style8">getPaymentAmount()</span> and thus must be abstract: </p><blockquote>  <pre>public abstract class Employee implements Payable{   //...}</pre></blockquote><p>Here's part of the code for a subclass of the previous class:</p><blockquote>  <pre>public class SalariedEmployee extends Employee{   //...   @Override   public double getPaymentAmount()   // POST: FCTVAL == amount paid to this employee each week in dollars   {      return getWeeklySalary();   }}</pre></blockquote><p>&nbsp;</p><p>We'll examine the idea of interfaces in much greater detail and with better examples in the next unit when we do event-driven programming. In Java, events from different sources (e.g. keyboard, mouse) are handled via interfaces.</p><p>&nbsp;</p><p>&nbsp;</p><p align="center"><font size="1"><a href="#idea">Polymorphism Defined</a> &bull; <a href="#isahasa">is-a/has-a</a> &bull; <a href="#abstract">Abstract Methods</a> &bull; <a href="#abclass">Abstract Classes</a> &bull; <a href="#ex">Example Code</a> &bull; <a href="#interface">Interfaces</a> &bull; <a href="#int_ex">Interface Code</a> </font></p></body></html>